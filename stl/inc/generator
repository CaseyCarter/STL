// generator standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _GENERATOR_
#define _GENERATOR_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#if !_HAS_CXX23 || !defined(__cpp_impl_coroutine)
#pragma message("The contents of <generator> are available only in c++latest mode with coroutine support")
#else // ^^^ no coroutine support / coroutines vvv

#include <coroutine>
#include <exception>
#include <xmemory>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

template <class _Ty, class _Ref = const _Ty&, class _Allocator = void>
class generator;

template <class _Ref>
class _Generator_promise_base {
public:
    _STL_INTERNAL_STATIC_ASSERT(is_reference_v<_Ref>);

    suspend_always initial_suspend() noexcept {
        return {};
    }

    auto final_suspend() noexcept {
        return _Final_awaiter{};
    }

    suspend_always yield_value(_Ref _Val) noexcept {
        _Ptr = _STD addressof(_Val);
        return {};
    }

    template <class _Ty, class _Ref2, class _Alloc>
        requires same_as<_Ref2&&, _Ref>
    auto yield_value(ranges::elements_of<generator<_Ty, _Ref2, _Alloc>> _Elem) noexcept {
        return _Nested_awaitable<_Ty, _Ref2, _Alloc>{_Elem.range()};
    }

    void await_transform() = delete;

    void return_void() noexcept {}

    void unhandled_exception() {
        if (_Info) {
            _Info->_Except = _STD current_exception();
        } else {
            throw;
        }
    }

private:
    struct _Nest_info {
        exception_ptr _Except;
        coroutine_handle<_Generator_promise_base> _Parent;
        coroutine_handle<_Generator_promise_base> _Root;
    };

    struct _Final_awaiter {
        bool await_ready() noexcept {
            return false;
        }

        template <class _Promise>
        coroutine_handle<> await_suspend(coroutine_handle<_Promise> _Handle) noexcept {
#ifndef __clang__ // TRANSITION, LLVM-48860
            _STL_INTERNAL_STATIC_ASSERT(is_pointer_interconvertible_base_of_v<_Generator_promise_base, _Promise>);
#endif // TRANSITION, LLVM-48860

            _Generator_promise_base& _Current = _Handle.promise();
            if (!_Current._Info) {
                return _STD noop_coroutine();
            }

            coroutine_handle<_Generator_promise_base> _Cont = _Current._Info->_Parent;
            _Current._Info->_Root.promise()._Top            = _Cont;
            _Current._Info                                  = nullptr;
            return _Cont;
        }

        void await_resume() noexcept {}
    };

    template <class _Ty, class _Ref2, class _Alloc>
    struct _Nested_awaitable {
        _Nest_info _Nested;
        generator<_Ty, _Ref2, _Alloc> _Gen;

        explicit _Nested_awaitable(generator<_Ty, _Ref2, _Alloc>&& _Gen_) noexcept : _Gen(_STD move(_Gen_)) {}

        bool await_ready() noexcept {
            return !_Gen._Coro;
        }

        template <class _Promise>
        coroutine_handle<_Generator_promise_base> await_suspend(coroutine_handle<_Promise> _Current) noexcept {
#ifndef __clang__ // TRANSITION, LLVM-48860
            _STL_INTERNAL_STATIC_ASSERT(is_pointer_interconvertible_base_of_v<_Generator_promise_base, _Promise>);
#endif // TRANSITION, LLVM-48860
            auto _Target    = coroutine_handle<_Generator_promise_base>::from_address(_Gen._Coro.address());
            _Nested._Parent = coroutine_handle<_Generator_promise_base>::from_address(_Current.address());
            _Generator_promise_base& _Parent_promise = _Nested._Parent.promise();
            if (_Parent_promise._Info) {
                _Nested._Root = _Parent_promise._Info->_Root;
            } else {
                _Nested._Root = _Nested._Parent;
            }
            _Nested._Root.promise()._Top = _Target;
            _Target.promise()._Info      = _STD addressof(_Nested);
            return _Target;
        }

        void await_resume() {
            if (_Nested._Except) {
                _STD rethrow_exception(_STD move(_Nested._Except));
            }
        }
    };

    template <class, class>
    friend class _Generator_iterator;

    coroutine_handle<_Generator_promise_base> _Top = coroutine_handle<_Generator_promise_base>::from_promise(*this);
    add_pointer_t<_Ref> _Ptr                       = nullptr;
    _Nest_info* _Info                              = nullptr;
};

template <class _Ty, class _Ref>
class _Generator_iterator {
public:
    _STL_INTERNAL_STATIC_ASSERT(is_reference_v<_Ref>);

    using difference_type = ptrdiff_t;
    using value_type      = _Ty;

    _Generator_iterator(_Generator_iterator&& _That) noexcept : _Coro{_STD exchange(_That._Coro, {})} {}

    _Generator_iterator& operator=(_Generator_iterator&& _That) noexcept {
        _Coro = _STD exchange(_That._Coro, {});
        return *this;
    }

    _NODISCARD _Ref operator*() const noexcept {
        _STL_ASSERT(!_Coro.done(), "Can't dereference generator end iterator");
        return static_cast<_Ref>(*_Coro.promise()._Top.promise()._Ptr);
    }

    _Generator_iterator& operator++() {
        _STL_ASSERT(!_Coro.done(), "Can't increment generator end iterator");
        _Coro.promise()._Top.resume();
        return *this;
    }

    void operator++(int) {
        ++*this;
    }

    _NODISCARD bool operator==(default_sentinel_t) const noexcept {
        return _Coro.done();
    }

private:
    template <class, class, class>
    friend class generator;

    explicit _Generator_iterator(coroutine_handle<_Generator_promise_base<_Ref>> _Coro_) noexcept : _Coro{_Coro_} {}

    coroutine_handle<_Generator_promise_base<_Ref>> _Coro;
};

template <class _Ty, class _Ref, class _Allocator>
class generator {
public:
    struct __declspec(empty_bases) promise_type : _Promise_allocator<_Allocator>, _Generator_promise_base<_Ref&&> {
        generator get_return_object() noexcept {
            return generator(coroutine_handle<promise_type>::from_promise(*this));
        }
    };
    _STL_INTERNAL_STATIC_ASSERT(is_standard_layout_v<promise_type>);
#ifndef __clang__ // TRANSITION, LLVM-48860
    _STL_INTERNAL_STATIC_ASSERT(is_pointer_interconvertible_base_of_v<_Generator_promise_base<_Ref&&>, promise_type>);
#endif // TRANSITION, LLVM-48860

    generator(generator&& _That) noexcept : _Coro(_STD exchange(_That._Coro, nullptr)) {}

    ~generator() {
        if (_Coro) {
            _Coro.destroy();
        }
    }

    generator& operator=(generator&& _That) noexcept {
        _Coro = _STD exchange(_That._Coro, nullptr);
        return *this;
    }

    _NODISCARD _Generator_iterator<_Ty, _Ref&&> begin() {
        // Pre: _Coro is suspended at its initial suspend point
        _STL_ASSERT(_Coro, "Can't call begin on moved-from generator");
        _Coro.resume();
        return _Generator_iterator<_Ty, _Ref&&>{
            coroutine_handle<_Generator_promise_base<_Ref&&>>::from_address(_Coro.address())};
    }

    _NODISCARD default_sentinel_t end() const noexcept {
        return default_sentinel;
    }

private:
    explicit generator(coroutine_handle<promise_type> _Coro_) noexcept : _Coro(_Coro_) {}

    friend _Generator_promise_base<_Ref&&>;

    coroutine_handle<promise_type> _Coro = nullptr;
};

namespace ranges {
    template <class _Ty, class _Ref, class _Allocator>
    inline constexpr bool enable_view<generator<_Ty, _Ref, _Allocator>> = true;
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // !_HAS_CXX23 || !defined(__cpp_lib_byte) || !defined(__cpp_impl_coroutine)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _GENERATOR_
