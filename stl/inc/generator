// generator standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _GENERATOR_
#define _GENERATOR_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#if !_HAS_CXX23 || !defined(__cpp_lib_byte) || !defined(__cpp_impl_coroutine)
#pragma message("The contents of <generator> are available only in c++latest mode with coroutine and std::byte support")
#else // ^^^ no coroutine support / coroutines vvv

#include <coroutine>
#include <ranges>
#include <xmemory>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

struct alignas(__STDCPP_DEFAULT_NEW_ALIGNMENT__) _Aligned_block {
    unsigned char _Pad[__STDCPP_DEFAULT_NEW_ALIGNMENT__];
};

template <class _Ty, class _Ref = const _Ty&, class _Alloc = void>
class generator {
    struct _Iterator;

public:
    static_assert(same_as<remove_cvref_t<_Ref>, _Ty>);

    class promise_type {
        add_pointer_t<_Ref> _Ptr = nullptr;

        friend _Iterator;

    public:
        generator get_return_object() noexcept {
            return generator(coroutine_handle<promise_type>::from_promise(*this));
        }

        suspend_always initial_suspend() noexcept {
            return {};
        }

        suspend_always final_suspend() noexcept {
            return {};
        }

        suspend_always yield_value(_Ref&& _Val) noexcept {
            _Ptr = _STD addressof(_Val);
            return {};
        }

        void await_transform() = delete; // TODO

        void return_void() noexcept {}

#ifndef _KERNEL_MODE
#ifdef _CPPUNWIND
        void unhandled_exception() {
            throw;
        }
#else // ^^^ defined(_CPPUNWIND) / !defined(_CPPUNWIND) vvv
        void unhandled_exception() noexcept {}
#endif // _CPPUNWIND
#endif // _KERNEL_MODE

        // clang-format off
        static void* operator new(size_t _Size) requires (is_void_v<_Alloc> || default_initializable<_Alloc>) {
            // clang-format on
            if constexpr (is_void_v<_Alloc>) {
                return ::operator new[](_Size);
            } else {
                _Rebind_alloc_t<_Alloc, _Aligned_block> _Al{};
                _Size = _Size / sizeof(_Aligned_block) + (_Size % sizeof(_Aligned_block) != 0);
                return _Al.allocate(_Size);
            }
        }

        // clang-format off
        static void operator delete(void* _Ptr, size_t _Size) noexcept
            requires (is_void_v<_Alloc> || default_initializable<_Alloc>) {
            // clang-format on
            if constexpr (is_void_v<_Alloc>) {
                return ::operator delete[](_Ptr, _Size);
            } else {
                _Rebind_alloc_t<_Alloc, _Aligned_block> _Al{};
                _Size = _Size / sizeof(_Aligned_block) + (_Size % sizeof(_Aligned_block) != 0);
                return _Al.deallocate(_Ptr, _Size);
            }
        }

#if 0 // TODO
        template <class _Alloc2, class... _Args>
        static void* operator new(size_t _Size, allocator_arg_t, _Alloc2& _Al, _Args&...);
        template <class _This, class _Alloc2, class... _Args>
        static void* operator new(size_t _Size, _This&, allocator_arg_t, _Alloc2& _Al, _Args&...);
#endif
    };

    generator(const generator&) = delete;

    generator(generator&& _Right) noexcept : _Coro(_STD exchange(_Right._Coro, nullptr)) {}

    ~generator() {
        if (_Coro) {
            _Coro.destroy();
        }
    }

    generator& operator=(const generator&) = delete;

    generator& operator=(generator&& _Right) noexcept {
        _Coro = _STD exchange(_Right._Coro, nullptr);
        return *this;
    }

    _NODISCARD auto begin() {
        // Pre: _Coro is suspended at its initial suspend point
#ifndef _KERNEL_MODE
        _STL_ASSERT(_Coro, "Can't call begin on moved-from generator");
#endif // _KERNEL_MODE
        _Coro.resume();
        return _Iterator{_Coro};
    }

    _NODISCARD default_sentinel_t end() const noexcept {
        return default_sentinel;
    }

private:
    struct _Iterator {
        using difference_type = ptrdiff_t;
        using value_type      = _Ty;

        coroutine_handle<promise_type> _Coro = nullptr;

        _NODISCARD _Ref&& operator*() const noexcept {
#ifndef _KERNEL_MODE
            _STL_ASSERT(!_Coro.done(), "Can't dereference generator end iterator");
#endif // _KERNEL_MODE
            return static_cast<_Ref&&>(*_Coro.promise()._Ptr);
        }

        _Iterator& operator++() {
#ifndef _KERNEL_MODE
            _STL_ASSERT(!_Coro.done(), "Can't increment generator end iterator");
#endif // _KERNEL_MODE
            _Coro.resume();
            return *this;
        }

        void operator++(int) {
            ++*this;
        }

        _NODISCARD bool operator==(default_sentinel_t) const noexcept {
            return _Coro.done();
        }
    };

    explicit generator(coroutine_handle<promise_type> _Coro_) noexcept : _Coro(_Coro_) {}

    coroutine_handle<promise_type> _Coro = nullptr;
};

namespace ranges {
    template <class _Ty, class _Ref, class _Alloc>
    inline constexpr bool enable_view<generator<_Ty, _Ref, _Alloc>> = true;
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // !_HAS_CXX23 || !defined(__cpp_lib_byte) || !defined(__cpp_impl_coroutine)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _GENERATOR_
