// generator standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _GENERATOR_
#define _GENERATOR_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#if !_HAS_CXX23 || !defined(__cpp_impl_coroutine)
#pragma message("The contents of <generator> are available only in c++latest mode with coroutine support")
#else // ^^^ no coroutine support / coroutines vvv

#include <coroutine>
#include <exception>
#include <ranges>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

template <class _Ty, class _Alloc = void, class _Uty = void>
class generator;

template <class _Ty, class _Uty>
using _Generator_value_t = conditional_t<is_void_v<_Uty>, remove_cvref_t<_Ty>, _Uty>;
template <class _Ty, class _Uty>
using _Generator_reference_t = conditional_t<is_void_v<_Uty>, conditional_t<is_reference_v<_Ty>, _Ty, const _Ty&>, _Ty>;

template <class _Ref>
using _Generator_yield_t = conditional_t<is_reference_v<_Ref>, _Ref, const _Ref&>;

template <class _Yielded>
class _Generator_promise_base {
public:
    _STL_INTERNAL_STATIC_ASSERT(is_reference_v<_Yielded>);

    /* _NODISCARD */ suspend_always initial_suspend() noexcept {
        return {};
    }

    _NODISCARD auto final_suspend() noexcept {
        return _Final_awaiter{};
    }

    _NODISCARD suspend_always yield_value(_Yielded _Val) noexcept {
        _Ptr = _STD addressof(_Val);
        return {};
    }

    // clang-format off
    template <class _Ty, class _Alloc, class _Uty, class _Alloc2>
        requires same_as<_Generator_yield_t<_Generator_reference_t<_Ty, _Uty>>, _Yielded>
    _NODISCARD auto yield_value(
        _RANGES elements_of<generator<_Ty, _Alloc, _Uty>, _Alloc2> _Elem) noexcept {
        // clang-format on
        return _Nested_awaitable<_Ty, _Alloc, _Uty>{_Elem.range()};
    }

    // clang-format off
    template <_RANGES input_range _Rng, class _Alloc>
        requires convertible_to<_RANGES range_reference_t<_Rng>, _Yielded>
    _NODISCARD auto yield_value(
        _RANGES elements_of<_Rng, _Alloc> _Elem) noexcept {
        // clang-format on
        using _Ty     = _RANGES range_value_t<_Rng>;
        auto&& _Range = _Elem.range();
        return _Nested_awaitable<_Yielded, _Alloc, _Ty>{
            [](allocator_arg_t, _Alloc, auto* _Range_ptr) -> generator<_Yielded, _Alloc, _Ty> {
                for (auto&& e : *_Range_ptr) {
                    co_yield static_cast<_Yielded>(_STD forward<decltype(e)>(e));
                }
            }(allocator_arg, _Elem.get_allocator(), _STD addressof(_Range))};
    }

    void await_transform() = delete;

    void return_void() noexcept {}

    void unhandled_exception() {
        if (_Info) {
            _Info->_Except = _STD current_exception();
        } else {
            throw;
        }
    }

private:
    struct _Nest_info {
        exception_ptr _Except;
        coroutine_handle<_Generator_promise_base> _Parent;
        coroutine_handle<_Generator_promise_base> _Root;
    };

    struct _Final_awaiter {
        _NODISCARD bool await_ready() noexcept {
            return false;
        }

        template <class _Promise>
        _NODISCARD coroutine_handle<> await_suspend(coroutine_handle<_Promise> _Handle) noexcept {
#ifdef __cpp_lib_is_pointer_interconvertible // TRANSITION, LLVM-48860
            _STL_INTERNAL_STATIC_ASSERT(is_pointer_interconvertible_base_of_v<_Generator_promise_base, _Promise>);
#endif // __cpp_lib_is_pointer_interconvertible

            _Generator_promise_base& _Current = _Handle.promise();
            if (!_Current._Info) {
                return _STD noop_coroutine();
            }

            coroutine_handle<_Generator_promise_base> _Cont = _Current._Info->_Parent;
            _Current._Info->_Root.promise()._Top            = _Cont;
            _Current._Info                                  = nullptr;
            return _Cont;
        }

        void await_resume() noexcept {}
    };

    template <class _Ty, class _Alloc, class _Uty>
    struct _Nested_awaitable {
        _STL_INTERNAL_STATIC_ASSERT(same_as<_Generator_yield_t<_Generator_reference_t<_Ty, _Uty>>, _Yielded>);

        _Nest_info _Nested;
        generator<_Ty, _Alloc, _Uty> _Gen;

        explicit _Nested_awaitable(generator<_Ty, _Alloc, _Uty>&& _Gen_) noexcept : _Gen(_STD move(_Gen_)) {}

        _NODISCARD bool await_ready() noexcept {
            return !_Gen._Coro;
        }

        template <class _Promise>
        _NODISCARD coroutine_handle<_Generator_promise_base> await_suspend(
            coroutine_handle<_Promise> _Current) noexcept {
#ifdef __cpp_lib_is_pointer_interconvertible // TRANSITION, LLVM-48860
            _STL_INTERNAL_STATIC_ASSERT(is_pointer_interconvertible_base_of_v<_Generator_promise_base, _Promise>);
#endif // __cpp_lib_is_pointer_interconvertible
            auto _Target    = coroutine_handle<_Generator_promise_base>::from_address(_Gen._Coro.address());
            _Nested._Parent = coroutine_handle<_Generator_promise_base>::from_address(_Current.address());
            _Generator_promise_base& _Parent_promise = _Nested._Parent.promise();
            if (_Parent_promise._Info) {
                _Nested._Root = _Parent_promise._Info->_Root;
            } else {
                _Nested._Root = _Nested._Parent;
            }
            _Nested._Root.promise()._Top = _Target;
            _Target.promise()._Info      = _STD addressof(_Nested);
            return _Target;
        }

        void await_resume() {
            if (_Nested._Except) {
                _STD rethrow_exception(_STD move(_Nested._Except));
            }
        }
    };

    template <class, class>
    friend class _Generator_iterator;

    // _Top and _Info are mutually exclusive, and could potentially be merged.
    coroutine_handle<_Generator_promise_base> _Top = coroutine_handle<_Generator_promise_base>::from_promise(*this);
    add_pointer_t<_Yielded> _Ptr                   = nullptr;
    _Nest_info* _Info                              = nullptr;
};

template <class _Value, class _Ref>
class _Generator_iterator {
public:
    using value_type      = _Value;
    using difference_type = ptrdiff_t;

    _Generator_iterator(_Generator_iterator&& _That) noexcept : _Coro{_STD exchange(_That._Coro, {})} {}

    _Generator_iterator& operator=(_Generator_iterator&& _That) noexcept {
        _Coro = _STD exchange(_That._Coro, {});
        return *this;
    }

    _NODISCARD _Ref operator*() const noexcept {
        _STL_ASSERT(!_Coro.done(), "Can't dereference generator end iterator");
        return static_cast<_Ref>(*_Coro.promise()._Top.promise()._Ptr);
    }

    _Generator_iterator& operator++() {
        _STL_ASSERT(!_Coro.done(), "Can't increment generator end iterator");
        _Coro.promise()._Top.resume();
        return *this;
    }

    void operator++(int) {
        ++*this;
    }

    _NODISCARD bool operator==(default_sentinel_t) const noexcept {
        return _Coro.done();
    }

private:
    template <class, class, class>
    friend class generator;

    explicit _Generator_iterator(coroutine_handle<_Generator_promise_base<_Generator_yield_t<_Ref>>> _Coro_) noexcept
        : _Coro{_Coro_} {}

    coroutine_handle<_Generator_promise_base<_Generator_yield_t<_Ref>>> _Coro;
};

template <class _Ty, class _Alloc, class _Uty>
class generator {
public:
    using _Value = _Generator_value_t<_Ty, _Uty>;
    static_assert(same_as<remove_cvref_t<_Value>, _Value> && is_object_v<_Value>,
        "generator's value type must be a cv-unqualified object type");

    // clang-format off
    using _Ref = _Generator_reference_t<_Ty, _Uty>;
    static_assert(is_reference_v<_Ref>
        || (is_object_v<_Ref> && same_as<remove_cv_t<_Ref>, _Ref> && copy_constructible<_Ref>),
        "generator's second argument must be a reference type or a cv-unqualified "
        "copy-constructible object type");

    using _RRef = conditional_t<is_lvalue_reference_v<_Ref>, remove_reference_t<_Ref>&&, _Ref>;

    static_assert(common_reference_with<_Ref&&, _Value&> && common_reference_with<_Ref&&, _RRef&&>
        && common_reference_with<_RRef&&, const _Value&>,
        "an iterator with the selected value and reference types cannot model indirectly_readable");
    // clang-format on

    struct __declspec(empty_bases) promise_type : _Promise_allocator<_Alloc>,
                                                  _Generator_promise_base<_Generator_yield_t<_Ref>> {
        _NODISCARD generator get_return_object() noexcept {
            return generator(coroutine_handle<promise_type>::from_promise(*this));
        }
    };
    _STL_INTERNAL_STATIC_ASSERT(is_standard_layout_v<promise_type>);
#ifdef __cpp_lib_is_pointer_interconvertible // TRANSITION, LLVM-48860
    _STL_INTERNAL_STATIC_ASSERT(
        is_pointer_interconvertible_base_of_v<_Generator_promise_base<_Generator_yield_t<_Ref>>, promise_type>);
#endif // __cpp_lib_is_pointer_interconvertible

    generator(generator&& _That) noexcept : _Coro(_STD exchange(_That._Coro, {})) {}

    ~generator() {
        if (_Coro) {
            _Coro.destroy();
        }
    }

    generator& operator=(generator&& _That) noexcept {
        if (auto _Old = _STD exchange(_Coro, _STD exchange(_That._Coro, {}))) {
            _Old.destroy();
        }
        return *this;
    }

    _NODISCARD _Generator_iterator<_Value, _Ref> begin() {
        // Pre: _Coro is suspended at its initial suspend point
        _STL_ASSERT(_Coro, "Can't call begin on moved-from generator");
        _Coro.resume();
        return _Generator_iterator<_Value, _Ref>{
            coroutine_handle<_Generator_promise_base<_Generator_yield_t<_Ref>>>::from_address(_Coro.address())};
    }

    _NODISCARD default_sentinel_t end() const noexcept {
        return default_sentinel;
    }

private:
    explicit generator(coroutine_handle<promise_type> _Coro_) noexcept : _Coro(_Coro_) {}

    friend _Generator_promise_base<_Generator_yield_t<_Ref>>;

    coroutine_handle<promise_type> _Coro = nullptr;
};

namespace ranges {
    template <class _Ty, class _Alloc, class _Uty>
    inline constexpr bool enable_view<generator<_Ty, _Alloc, _Uty>> = true;
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // !_HAS_CXX23 || !defined(__cpp_impl_coroutine)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _GENERATOR_
