// any standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _ANY_
#define _ANY_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#if !_HAS_CXX17
#pragma message("The contents of <any> are available only with C++17 or later.")
#else // ^^^ !_HAS_CXX17 / _HAS_CXX17 vvv
#include <initializer_list>
#include <type_traits>
#include <typeinfo>
#include <utility>
#include <xmemory>

#if !_HAS_STATIC_RTTI
#error class any requires static RTTI.
#endif // _HAS_STATIC_RTTI

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

// CLASS bad_any_cast
class bad_any_cast : public bad_cast { // thrown by failed any_cast
public:
    _NODISCARD virtual const char* __CLR_OR_THIS_CALL what() const noexcept override {
        return "Bad any_cast";
    }
};

[[noreturn]] inline void _Throw_bad_any_cast() {
    _THROW(bad_any_cast{});
}

// CLASS any
struct _Any_vtable;
extern const _Any_vtable _Any_null_vtable;

struct alignas(max_align_t) _Any_storage {
    union {
        unsigned char _Data[3 * sizeof(void*)];
        void* _Ptr;
    };

    const _Any_vtable* _Vtable = &_Any_null_vtable;
};
_STL_INTERNAL_STATIC_ASSERT(is_standard_layout_v<_Any_storage>);
_STL_INTERNAL_STATIC_ASSERT(sizeof(_Any_storage) == 4 * sizeof(void*));
_STL_INTERNAL_STATIC_ASSERT(alignof(_Any_storage) == alignof(max_align_t));

template <class _Ty>
inline constexpr bool _Any_is_small = alignof(_Ty) <= alignof(_Any_storage)
                                      && sizeof(_Ty) <= sizeof(_Any_storage::_Data)
                                      && is_nothrow_move_constructible_v<_Ty>;

struct _Any_vtable {
    using _Get_fn     = void* __CLRCALL_PURE_OR_CDECL(_Any_storage&) noexcept;
    using _Copy_fn    = void __CLRCALL_PURE_OR_CDECL(_Any_storage&, const _Any_storage&);
    using _Move_fn    = void __CLRCALL_PURE_OR_CDECL(_Any_storage&, _Any_storage&) noexcept;
    using _Destroy_fn = void __CLRCALL_PURE_OR_CDECL(_Any_storage&) noexcept;

    const type_info& _Type;
    _Get_fn& _Get;
    _Copy_fn& _Copy;
    _Move_fn& _Move;
    _Destroy_fn& _Destroy;
};

struct _Any_trivial_impl {
    _NODISCARD static void* __CLRCALL_PURE_OR_CDECL _Get(_Any_storage&) noexcept {
        return nullptr;
    }
    static void __CLRCALL_PURE_OR_CDECL _Copy(_Any_storage& _Target, const _Any_storage& _Source) noexcept {
        _Target = _Source;
    }
    static void __CLRCALL_PURE_OR_CDECL _Move(_Any_storage& _Target, _Any_storage& _Source) noexcept {
        _Target = _Source;
    }
    static void __CLRCALL_PURE_OR_CDECL _Destroy(_Any_storage&) noexcept {}
};

inline constexpr _Any_vtable _Any_null_vtable = {
    typeid(void),
    _Any_trivial_impl::_Get,
    _Any_trivial_impl::_Copy,
    _Any_trivial_impl::_Move,
    _Any_trivial_impl::_Destroy,
};

struct _Any_small_impl {
    _NODISCARD static void* __CLRCALL_PURE_OR_CDECL _Get(_Any_storage& _Sto) noexcept {
        return _Sto._Data;
    }

    template <class _Ty>
    static void __CLRCALL_PURE_OR_CDECL _Copy(_Any_storage& _Target, const _Any_storage& _Source) {
        ::new (_Target._Data) _Ty(reinterpret_cast<const _Ty&>(_Source._Data));
        _Target._Vtable = _Source._Vtable;
    }

    template <class _Ty>
    static void __CLRCALL_PURE_OR_CDECL _Move(_Any_storage& _Target, _Any_storage& _Source) noexcept {
        ::new (_Target._Data) _Ty(reinterpret_cast<_Ty&&>(_Source._Data));
        _Target._Vtable = _Source._Vtable;
    }

    template <class _Ty>
    static void __CLRCALL_PURE_OR_CDECL _Destroy(_Any_storage& _Target) noexcept {
        reinterpret_cast<_Ty&>(_Target._Data).~_Ty();
    }
};

struct _Any_big_impl {
    _NODISCARD static void* __CLRCALL_PURE_OR_CDECL _Get(_Any_storage& _Sto) noexcept {
        return _Sto._Ptr;
    }

    template <class _Ty>
    static void __CLRCALL_PURE_OR_CDECL _Copy(_Any_storage& _Target, const _Any_storage& _Source) {
        _Target._Ptr    = ::new _Ty(*static_cast<const _Ty*>(_Source._Ptr));
        _Target._Vtable = _Source._Vtable;
    }

    static void __CLRCALL_PURE_OR_CDECL _Move(_Any_storage& _Target, _Any_storage& _Source) noexcept {
        _Target._Ptr    = _Source._Ptr;
        _Target._Vtable = _Source._Vtable;
        _Source._Vtable = &_Any_null_vtable;
    }

    template <class _Ty>
    static void __CLRCALL_PURE_OR_CDECL _Destroy(_Any_storage& _Sto) noexcept {
        ::delete static_cast<_Ty*>(_Sto._Ptr);
    }
};

template <class _Ty, bool = _Any_is_small<_Ty>>
inline constexpr _Any_vtable _Any_vtable_for = {
    typeid(_Ty),
    _Any_small_impl::_Get,
    is_trivially_copy_constructible_v<_Ty> ? _Any_trivial_impl::_Copy : _Any_small_impl::_Copy<_Ty>,
    is_trivially_move_constructible_v<_Ty> ? _Any_trivial_impl::_Move : _Any_small_impl::_Move<_Ty>,
    is_trivially_destructible_v<_Ty> ? _Any_trivial_impl::_Destroy : _Any_small_impl::_Destroy<_Ty>,
};

template <class _Ty>
inline constexpr _Any_vtable _Any_vtable_for<_Ty, false> = {
    typeid(_Ty),
    _Any_big_impl::_Get,
    _Any_big_impl::_Copy<_Ty>,
    _Any_big_impl::_Move,
    _Any_big_impl::_Destroy<_Ty>,
};

class any { // storage for any (CopyConstructible) type
public:
    // Construction and destruction [any.cons]
    constexpr any() noexcept : _Storage{} {}

    any(const any& _That) {
        _That._Storage._Vtable->_Copy(_Storage, _That._Storage);
    }

    any(any&& _That) noexcept {
        _That._Storage._Vtable->_Move(_Storage, _That._Storage);
    }

    template <class _ValueType, enable_if_t<conjunction_v<negation<is_same<decay_t<_ValueType>, any>>,
                                                negation<_Is_specialization<decay_t<_ValueType>, in_place_type_t>>,
                                                is_copy_constructible<decay_t<_ValueType>>>,
                                    int> = 0>
    any(_ValueType&& _Value) { // initialize with _Value
        _Emplace<decay_t<_ValueType>>(_STD forward<_ValueType>(_Value));
    }

    template <class _ValueType, class... _Types,
        enable_if_t<
            conjunction_v<is_constructible<decay_t<_ValueType>, _Types...>, is_copy_constructible<decay_t<_ValueType>>>,
            int> = 0>
    explicit any(in_place_type_t<_ValueType>, _Types&&... _Args) {
        // in-place initialize a value of type decay_t<_ValueType> with _Args...
        _Emplace<decay_t<_ValueType>>(_STD forward<_Types>(_Args)...);
    }

    template <class _ValueType, class _Elem, class... _Types,
        enable_if_t<conjunction_v<is_constructible<decay_t<_ValueType>, initializer_list<_Elem>&, _Types...>,
                        is_copy_constructible<decay_t<_ValueType>>>,
            int> = 0>
    explicit any(in_place_type_t<_ValueType>, initializer_list<_Elem> _Ilist, _Types&&... _Args) {
        // in-place initialize a value of type decay_t<_ValueType> with _Ilist and _Args...
        _Emplace<decay_t<_ValueType>>(_Ilist, _STD forward<_Types>(_Args)...);
    }

    ~any() noexcept {
        _Storage._Vtable->_Destroy(_Storage);
    }

    // Assignment [any.assign]
    any& operator=(const any& _That) {
        any{_That}.swap(*this);
        return *this;
    }

    any& operator=(any&& _That) noexcept {
        any{_STD move(_That)}.swap(*this);
        return *this;
    }

    template <class _ValueType, enable_if_t<conjunction_v<negation<is_same<decay_t<_ValueType>, any>>,
                                                is_copy_constructible<decay_t<_ValueType>>>,
                                    int> = 0>
    any& operator=(_ValueType&& _Value) {
        // replace contained value with an object of type decay_t<_ValueType> initialized from _Value
        any{_STD forward<_ValueType>(_Value)}.swap(*this);
        return *this;
    }

    // Modifiers [any.modifiers]
    template <class _ValueType, class... _Types,
        enable_if_t<
            conjunction_v<is_constructible<decay_t<_ValueType>, _Types...>, is_copy_constructible<decay_t<_ValueType>>>,
            int> = 0>
    decay_t<_ValueType>& emplace(_Types&&... _Args) {
        // replace contained value with an object of type decay_t<_ValueType> initialized from _Args...
        _Storage._Vtable->_Destroy(_Storage);
        _Emplace_guard _Guard{this};
        decay_t<_ValueType>& _Result = _Emplace<decay_t<_ValueType>>(_STD forward<_Types>(_Args)...);
        _Guard._Ptr                  = nullptr;
        return _Result;
    }

    template <class _ValueType, class _Elem, class... _Types,
        enable_if_t<conjunction_v<is_constructible<decay_t<_ValueType>, initializer_list<_Elem>&, _Types...>,
                        is_copy_constructible<decay_t<_ValueType>>>,
            int> = 0>
    decay_t<_ValueType>& emplace(initializer_list<_Elem> _Ilist, _Types&&... _Args) {
        // replace contained value with an object of type decay_t<_ValueType> initialized from _Ilist and _Args...
        _Storage._Vtable->_Destroy(_Storage);
        _Emplace_guard _Guard{this};
        decay_t<_ValueType>& _Result = _Emplace<decay_t<_ValueType>>(_Ilist, _STD forward<_Types>(_Args)...);
        _Guard._Ptr                  = nullptr;
        return _Result;
    }

    void reset() noexcept { // transition to the empty state
        _Storage._Vtable->_Destroy(_Storage);
        _Storage._Vtable = &_Any_null_vtable;
    }

    void swap(any& _That) noexcept {
        _STD swap(_Storage, _That._Storage);
    }

    // Observers [any.observers]
    _NODISCARD bool has_value() const noexcept {
        return _Storage._Vtable->_Type != typeid(void);
    }

    _NODISCARD const type_info& type() const noexcept {
        // if *this contains a value of type T, return typeid(T); otherwise typeid(void)
        return _Storage._Vtable->_Type;
    }

    template <class _Decayed>
    _NODISCARD _Decayed* _Cast() noexcept { // if *this contains a value of type _Decayed, return a pointer to it
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Decayed, decay_t<_Decayed>>);
        _STL_INTERNAL_STATIC_ASSERT(!is_void_v<_Decayed>);

        if (_Storage._Vtable->_Type != typeid(_Decayed)) {
            return nullptr;
        }

        return static_cast<_Decayed*>(_Storage._Vtable->_Get(_Storage));
    }

    template <class _Decayed>
    _NODISCARD const _Decayed* _Cast() const noexcept {
        // if *this contains a value of type _Decayed, return a pointer to it
        return const_cast<any*>(this)->_Cast<_Decayed>();
    }

private:
    struct _Emplace_guard {
        any* _Ptr;

        ~_Emplace_guard() {
            if (_Ptr) {
                _Ptr->_Storage._Vtable = &_Any_null_vtable;
            }
        }
    };

    template <class _Decayed, class... _Types>
    _Decayed& _Emplace(_Types&&... _Args) { // emplace construct _Decayed
        _Storage._Vtable = &_Any_vtable_for<_Decayed>;
        if constexpr (_Any_is_small<_Decayed>) {
            // using the _Small representation
            auto& _Obj = reinterpret_cast<_Decayed&>(_Storage._Data);
            _Construct_in_place(_Obj, _STD forward<_Types>(_Args)...);
            return _Obj;
        } else {
            // using the _Big representation
            auto const _Ptr = ::new _Decayed(_STD forward<_Types>(_Args)...);
            _Storage._Ptr   = _Ptr;
            return *_Ptr;
        }
    }

    _Any_storage _Storage;
};

// Non-member functions [any.nonmembers]
inline void swap(any& _Left, any& _Right) noexcept {
    _Left.swap(_Right);
}

template <class _ValueType, class... _Types>
_NODISCARD any make_any(_Types&&... _Args) { // construct an any containing a _ValueType initialized with _Args...
    return any{in_place_type<_ValueType>, _STD forward<_Types>(_Args)...};
}
template <class _ValueType, class _Elem, class... _Types>
_NODISCARD any make_any(initializer_list<_Elem> _Ilist, _Types&&... _Args) {
    // construct an any containing a _ValueType initialized with _Ilist and _Args...
    return any{in_place_type<_ValueType>, _Ilist, _STD forward<_Types>(_Args)...};
}

template <class _ValueType>
_NODISCARD const _ValueType* any_cast(const any* const _Any) noexcept {
    // retrieve a pointer to the _ValueType contained in _Any, or null
    static_assert(!is_void_v<_ValueType>, "std::any cannot contain void.");

    if constexpr (is_function_v<_ValueType> || is_array_v<_ValueType>) {
        return nullptr;
    } else {
        if (!_Any) {
            return nullptr;
        }

        return _Any->_Cast<_Remove_cvref_t<_ValueType>>();
    }
}
template <class _ValueType>
_NODISCARD _ValueType* any_cast(any* const _Any) noexcept {
    // retrieve a pointer to the _ValueType contained in _Any, or null
    static_assert(!is_void_v<_ValueType>, "std::any cannot contain void.");

    if constexpr (is_function_v<_ValueType> || is_array_v<_ValueType>) {
        return nullptr;
    } else {
        if (!_Any) {
            return nullptr;
        }

        return _Any->_Cast<_Remove_cvref_t<_ValueType>>();
    }
}

template <class _Ty>
_NODISCARD remove_cv_t<_Ty> any_cast(const any& _Any) {
    static_assert(is_constructible_v<remove_cv_t<_Ty>, const _Remove_cvref_t<_Ty>&>,
        "any_cast<T>(const any&) requires remove_cv_t<T> to be constructible from "
        "const remove_cv_t<remove_reference_t<T>>&");

    const auto _Ptr = _STD any_cast<_Remove_cvref_t<_Ty>>(&_Any);
    if (!_Ptr) {
        _Throw_bad_any_cast();
    }

    return static_cast<remove_cv_t<_Ty>>(*_Ptr);
}
template <class _Ty>
_NODISCARD remove_cv_t<_Ty> any_cast(any& _Any) {
    static_assert(is_constructible_v<remove_cv_t<_Ty>, _Remove_cvref_t<_Ty>&>,
        "any_cast<T>(any&) requires remove_cv_t<T> to be constructible from remove_cv_t<remove_reference_t<T>>&");

    const auto _Ptr = _STD any_cast<_Remove_cvref_t<_Ty>>(&_Any);
    if (!_Ptr) {
        _Throw_bad_any_cast();
    }

    return static_cast<remove_cv_t<_Ty>>(*_Ptr);
}
template <class _Ty>
_NODISCARD remove_cv_t<_Ty> any_cast(any&& _Any) {
    static_assert(is_constructible_v<remove_cv_t<_Ty>, _Remove_cvref_t<_Ty>>,
        "any_cast<T>(any&&) requires remove_cv_t<T> to be constructible from remove_cv_t<remove_reference_t<T>>");

    const auto _Ptr = _STD any_cast<_Remove_cvref_t<_Ty>>(&_Any);
    if (!_Ptr) {
        _Throw_bad_any_cast();
    }

    return static_cast<remove_cv_t<_Ty>>(_STD move(*_Ptr));
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _HAS_CXX17

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _ANY_
