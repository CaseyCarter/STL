// lazy standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _LAZY_
#define _LAZY_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#if !_HAS_CXX23 || !defined(__cpp_impl_coroutine)
#pragma message("The contents of <lazy> are available only in c++latest mode with coroutine support")
#else // ^^^ no coroutine support / coroutines vvv

#include <coroutine>
#include <exception>
#include <xmemory>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

template <class _Ty = void, class _Allocator = void>
class [[nodiscard]] lazy;

template <class _Ty>
class _Lazy_promise_base {
public:
    _Lazy_promise_base() noexcept {}

    _Lazy_promise_base(_Lazy_promise_base&& _That) noexcept(is_nothrow_move_constructible_v<_Ty>) : _Disc{_That._Disc} {
        switch (_Disc) {
        case _Discriminator::_Empty:
            break;
        case _Discriminator::_Data:
            _Construct_in_place(_Data, _STD move(_That._Data));
            _Destroy_in_place(_That._Data);
            break;
        case _Discriminator::_Exception:
            _Construct_in_place(_Except, _STD move(_That._Except));
            _Destroy_in_place(_That._Except);
            break;
        }

        _That._Disc = _Discriminator::_Empty;
    }

    ~_Lazy_promise_base() {
        switch (_Disc) {
        case _Discriminator::_Empty:
            break;
        case _Discriminator::_Data:
            _Destroy_in_place(_Data);
            break;
        case _Discriminator::_Exception:
            _Destroy_in_place(_Except);
            break;
        }
    }

    /* _NODISCARD */ suspend_always initial_suspend() noexcept {
        return {};
    }

    _NODISCARD auto final_suspend() noexcept {
        return _Final_awaiter{};
    }

    void return_value(_Ty _Val) noexcept requires is_reference_v<_Ty> {
        switch (_Disc) {
        case _Discriminator::_Exception:
            break;
        case _Discriminator::_Empty:
            // _Data is a pointer, we can begin its lifetime by assigning
        case _Discriminator::_Data:
            _Data = _STD addressof(_Val);
            _Disc = _Discriminator::_Data;
            break;
        }
    }

    // clang-format off
    template <class _Uty>
        requires (!is_reference_v<_Ty> && convertible_to<_Uty, _Ty> && constructible_from<_Ty, _Uty>)
    void return_value(_Uty&& _Val) noexcept(is_nothrow_constructible_v<_Uty, _Ty>) {
        // clang-format on
        switch (_Disc) {
        case _Discriminator::_Exception:
            break;
        case _Discriminator::_Data:
            _Destroy_in_place(_Data);
            _Disc = _Discriminator::_Empty;
            [[fallthrough]];
        case _Discriminator::_Empty:
            _Construct_in_place(_Data, _STD forward<_Uty>(_Val));
            _Disc = _Discriminator::_Data;
        }
    }

    void unhandled_exception() {
        switch (_Disc) {
        case _Discriminator::_Exception:
            break;
        case _Discriminator::_Data:
            _Destroy_in_place(_Data);
            _Disc = _Discriminator::_Empty;
            [[fallthrough]];
        case _Discriminator::_Empty:
            _Construct_in_place(_Except, _STD current_exception());
            _Disc = _Discriminator::_Exception;
            break;
        }
    }

private:
    template <class, class>
    friend class lazy;

    struct _Final_awaiter {
        _NODISCARD bool await_ready() noexcept {
            return false;
        }

        template <class _Promise>
        _NODISCARD coroutine_handle<> await_suspend(coroutine_handle<_Promise> _Coro) noexcept {
#ifdef __cpp_lib_is_pointer_interconvertible // TRANSITION, LLVM-48860
            _STL_INTERNAL_STATIC_ASSERT(is_pointer_interconvertible_base_of_v<_Lazy_promise_base, _Promise>);
#endif // __cpp_lib_is_pointer_interconvertible

            _Lazy_promise_base& _Current = _Coro.promise();
            return _Current._Cont ? _Current._Cont : _STD noop_coroutine();
        }

        void await_resume() noexcept {}
    };

    struct _Awaiter {
        coroutine_handle<_Lazy_promise_base> _Coro;

        _NODISCARD bool await_ready() noexcept {
            return !_Coro;
        }

        _NODISCARD coroutine_handle<_Lazy_promise_base> await_suspend(coroutine_handle<> _Cont) noexcept {
            _Coro.promise()._Cont = _Cont;
            return _Coro;
        }

        _Ty await_resume() {
            auto& _Promise = _Coro.promise();
            switch (_Promise._Disc) {
            case _Discriminator::_Data:
                if constexpr (is_reference_v<_Ty>) {
                    return static_cast<_Ty>(*_Promise._Data);
                } else {
                    return _STD move(_Promise._Data);
                }
            case _Discriminator::_Exception:
                _STL_ASSERT(_Promise._Except, "This can't happen?");
                _STD rethrow_exception(_STD move(_Promise._Except));
            default:
            case _Discriminator::_Empty:
                _STL_ASSERT(false, "This can't happen?");
                _STD terminate();
            }
        }
    };

    enum class _Discriminator : unsigned char { _Empty, _Exception, _Data };
    union {
        exception_ptr _Except;
        conditional_t<is_reference_v<_Ty>, add_pointer_t<_Ty>, _Ty> _Data;
    };
    _Discriminator _Disc = _Discriminator::_Empty;
    coroutine_handle<> _Cont;
};

template <class _Ty>
    requires is_void_v<_Ty>
class _Lazy_promise_base<_Ty> {
public:
    _Lazy_promise_base() noexcept {}

    _Lazy_promise_base(_Lazy_promise_base&& _That) noexcept(is_nothrow_move_constructible_v<_Ty>) : _Disc{_That._Disc} {
        if (_Disc == _Discriminator::_Exception) {
            _Construct_in_place(_Except, _STD move(_That._Except));
            _Destroy_in_place(_That._Except);
            _That._Disc = _Discriminator::_Empty;
        }
    }

    ~_Lazy_promise_base() {
        if (_Disc == _Discriminator::_Exception) {
            _Destroy_in_place(_Except);
        }
    }

    _NODISCARD suspend_always initial_suspend() noexcept {
        return {};
    }

    _NODISCARD auto final_suspend() noexcept {
        return _Final_awaiter{};
    }

    void return_void() noexcept {}

    void unhandled_exception() {
        if (_Disc == _Discriminator::_Empty) {
            _Construct_in_place(_Except, _STD current_exception());
            _Disc = _Discriminator::_Exception;
        }
    }

private:
    template <class, class>
    friend class lazy;

    struct _Final_awaiter {
        _NODISCARD bool await_ready() noexcept {
            return false;
        }

        template <class _Promise>
        _NODISCARD coroutine_handle<> await_suspend(coroutine_handle<_Promise> _Coro) noexcept {
#ifdef __cpp_lib_is_pointer_interconvertible // TRANSITION, LLVM-48860
            _STL_INTERNAL_STATIC_ASSERT(is_pointer_interconvertible_base_of_v<_Lazy_promise_base, _Promise>);
#endif // __cpp_lib_is_pointer_interconvertible

            _Lazy_promise_base& _Current = _Coro.promise();
            return _Current._Cont ? _Current._Cont : _STD noop_coroutine();
        }

        void await_resume() noexcept {}
    };

    struct _Awaiter {
        coroutine_handle<_Lazy_promise_base> _Coro;

        _NODISCARD bool await_ready() noexcept {
            return !_Coro;
        }

        _NODISCARD coroutine_handle<_Lazy_promise_base> await_suspend(coroutine_handle<> _Cont) noexcept {
            _Coro.promise()._Cont = _Cont;
            return _Coro;
        }

        void await_resume() {
            auto& _Promise = _Coro.promise();
            if (_Promise._Disc == _Discriminator::_Exception) {
                _STD rethrow_exception(_STD move(_Promise._Except));
            }
        }
    };

    enum class _Discriminator : unsigned char { _Empty, _Exception };
    union {
        exception_ptr _Except;
    };
    _Discriminator _Disc = _Discriminator::_Empty;
    coroutine_handle<> _Cont;
};

template <class _Ty, class _Allocator>
class [[nodiscard]] lazy {
public:
    static_assert(is_void_v<_Ty> || is_reference_v<_Ty> || (is_object_v<_Ty> && is_move_constructible_v<_Ty>),
        "lazy's first template argument must be void, a reference type, or a move-constructible object type");

    struct __declspec(empty_bases) promise_type : _Promise_allocator<_Allocator>, _Lazy_promise_base<_Ty> {
        _NODISCARD lazy get_return_object() noexcept {
            return lazy{coroutine_handle<promise_type>::from_promise(*this)};
        }
    };

    lazy(lazy&& _That) noexcept : _Coro(_STD exchange(_That._Coro, {})) {}

    ~lazy() {
        if (_Coro) {
            _Coro.destroy();
        }
    }

    _NODISCARD typename _Lazy_promise_base<_Ty>::_Awaiter operator co_await() {
        // Pre: _Coro refers to a coroutine suspended at its initial suspend point
        auto& _Promise_base = static_cast<_Lazy_promise_base<_Ty>&>(_Coro.promise());
        return typename _Lazy_promise_base<_Ty>::_Awaiter{
            coroutine_handle<_Lazy_promise_base<_Ty>>::from_promise(_Promise_base)};
    }

    _NODISCARD _Ty sync_await() {
        return _Sync_await(*this);
    }

private:
    friend _Lazy_promise_base<_Ty>;

    explicit lazy(coroutine_handle<promise_type> _Coro_) noexcept : _Coro(_Coro_) {}

    coroutine_handle<promise_type> _Coro = nullptr;
};

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // !_HAS_CXX23 || !defined(__cpp_impl_coroutine)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _LAZY_
